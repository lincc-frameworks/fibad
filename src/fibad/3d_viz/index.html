<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Interactive 3D UMAP Visualization</title>
        
	    <!-- Include Three.js and OrbitControls for 3D visualization -->	
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/controls/OrbitControls.js"></script>
        
		<style>
            
			body { margin: 0; overflow: hidden; background-color: black; }
            canvas { display: block; }
    
			/* Stying of Box Containing Object IDs*/
            #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: yellow;
            font-size: 14px;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            max-width: 75vw;  /* 75% of viewport width */
            max-height: 200px; /* Limits height */
            overflow-y: auto;  /* Enables scrolling */
            border-radius: 5px;
            word-wrap: break-word; /* Ensures long words wrap */
            white-space: normal; /* Allows text to break into new lines */
            }

			#selectionBox {
            position: absolute;
            border: 2px dashed yellow;
            background-color: rgba(255, 255, 0, 0.2);
            display: none;
            }


			/* Stying of Box Showing Control Instructions*/
            #controls-box {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            font-family: Arial, sans-serif;
            max-width: 250px;
            text-align: left;
            }

            #controls-box h3 {
            margin: 0;
            font-size: 16px;
            color: yellow;
            }

            #controls-box ul {
            padding: 0;
            list-style-type: none;
            }

            #controls-box li {
            margin-bottom: 5px;
            }

        </style>
    </head>

    <body>

		<!-- Control instructions box -->
        <div id="controls-box">
            <h3>Controls</h3>
            <ul>
                <li><b>Move Camera:</b> Left-click + drag</li>
                <li><b>Zoom:</b> Scroll</li>
                <li><b>Select Points:</b> Hold <b>S</b> + Left-click + Drag</li>
                <li><b>Selection Behavior:</b> Selected points turn <span style="color: red;">red</span>, previous selections is cleared
                    </span>
                </li>
            </ul>
        </div>


		<!-- Information text -->
        <div id="info">Drag to select multiple points</div>
        
		<!-- Selection box -->
		<div id="selectionBox"></div>
        <script>
            let scene, camera, renderer, pointCloud, controls;
            let points = [];
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let isSelecting = false;
            let startX, startY, endX, endY;
            let selectedPoints = [];
            const selectionBox = document.getElementById("selectionBox");
            let isSKeyPressed = false;
            
            function init() {

				// Set up new 3js Scene
                scene = new THREE.Scene();
               
				// Set up Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 10);
                
				// Set up renderer
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                
				// Add orbit controls for camera movement
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.03;
                controls.minDistance = 1;
                controls.maxDistance = 20;
                
				// Load UMAP data from JSON file 
                fetch("umap_data.json")
                    .then(response => response.json())
                    .then(data => {
                        points = data.points;
                        createPointCloud();
                    })
                    .catch(error => console.error("Error loading JSON:", error));
                
				// Start rendering loop
                animate();
            }
            
            function createPointCloud() {
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
            
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
            
				// Calculate data bounds for normalization
                points.forEach(p => {
                    minX = Math.min(minX, p.x);
                    minY = Math.min(minY, p.y);
                    minZ = Math.min(minZ, p.z);
                    maxX = Math.max(maxX, p.x);
                    maxY = Math.max(maxY, p.y);
                    maxZ = Math.max(maxZ, p.z);
                });
            
                const scaleFactor = 5 / Math.max(maxX - minX, maxY - minY, maxZ - minZ);
            
				// Normalize and store point positions and colors
                points.forEach(point => {
                    let x = (point.x - (minX + maxX) / 2) * scaleFactor;
                    let y = (point.y - (minY + maxY) / 2) * scaleFactor;
                    let z = (point.z - (minZ + maxZ) / 2) * scaleFactor;
            
                    positions.push(x, y, z);
                    colors.push(1, 1, 0); // Yellow color
                });
            
                geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
            
				// Create point cloud material and add to scene
                const material = new THREE.PointsMaterial({ size: 0.05, vertexColors: true });
                pointCloud = new THREE.Points(geometry, material);
                scene.add(pointCloud);
            }
            
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }


			
            // Mouse interaction functions
            function onMouseDown(event) {
            if (event.button !== 0 || !isSKeyPressed) return; // Only activate if "S" is held during left-click
            
            isSelecting = true;
            controls.enabled = false; //disable camera movement 
            startX = event.clientX;
            startY = event.clientY;
            selectionBox.style.left = `${startX}px`;
            selectionBox.style.top = `${startY}px`;
            selectionBox.style.width = "0px";
            selectionBox.style.height = "0px";
            selectionBox.style.display = "block";
            
            event.preventDefault(); // Prevent interfering interactions
            }
            
            
            function onMouseMove(event) {
            if (!isSelecting || !isSKeyPressed) return;  // Stop selection if "S" is not held
            
            endX = event.clientX;
            endY = event.clientY;
            
            selectionBox.style.left = `${Math.min(startX, endX)}px`;
            selectionBox.style.top = `${Math.min(startY, endY)}px`;
            selectionBox.style.width = `${Math.abs(endX - startX)}px`;
            selectionBox.style.height = `${Math.abs(endY - startY)}px`;
            }
            
            
            
            function onMouseUp() {
            if (!isSKeyPressed) {
                isSelecting = false;
                selectionBox.style.display = "none";
                controls.enabled = true;
                return;
            }
            
            isSelecting = false;
            selectionBox.style.display = "none";
            controls.enabled = true;
            
            const minX = (Math.min(startX, endX) / window.innerWidth) * 2 - 1;
            const maxX = (Math.max(startX, endX) / window.innerWidth) * 2 - 1;
            const minY = -(Math.max(startY, endY) / window.innerHeight) * 2 + 1;
            const maxY = -(Math.min(startY, endY) / window.innerHeight) * 2 + 1;
            
            selectedPoints = [];
            
            const geometry = pointCloud.geometry;
            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color.array;
            
            // Reset all points to yellow before selecting new ones
            for (let i = 0; i < colors.length / 3; i++) {
                colors[i * 3] = 1; // Red channel
                colors[i * 3 + 1] = 1; // Green channel
                colors[i * 3 + 2] = 0; // Blue channel (Yellow color)
            }
            
            // Now apply selection (turn selected points red)
            for (let i = 0; i < positions.length / 3; i++) {
                const vector = new THREE.Vector3(
                    positions[i * 3],
                    positions[i * 3 + 1],
                    positions[i * 3 + 2]
                ).project(camera);
            
                if (vector.x >= minX && vector.x <= maxX && vector.y >= minY && vector.y <= maxY) {
                    selectedPoints.push(points[i].id);
                    colors[i * 3] = 1; // Red channel
                    colors[i * 3 + 1] = 0; // Green channel
                    colors[i * 3 + 2] = 0; // Blue channel (Red color)
                }
            }
            
            // Update color buffer to reflect changes
            geometry.attributes.color.needsUpdate = true;
            
            document.getElementById("info").innerHTML = `Selected Object IDs: <b>${selectedPoints.join(", ")}</b>`;
            }
            
            
            window.addEventListener("mousedown", onMouseDown, false);
            window.addEventListener("mousemove", onMouseMove, false);
            window.addEventListener("mouseup", onMouseUp, false);
            

			// Handle keyboard events for selection mode
            window.addEventListener("keydown", (event) => {
            if (event.key.toLowerCase() === "s") {
                isSKeyPressed = true;
            }
            });
            
            window.addEventListener("keyup", (event) => {
            if (event.key.toLowerCase() === "s") {
                isSKeyPressed = false;
                isSelecting = false;
                selectionBox.style.display = "none";
                controls.enabled = true; //Re-enable camera movement
            }
            });
            
            
            init();
        </script>
    </body>
</html>
